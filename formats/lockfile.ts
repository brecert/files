// deno-lint-ignore-file camelcase
import { crypto } from "https://deno.land/std@0.114.0/crypto/mod.ts";
import { ensureDir } from "https://deno.land/std@0.114.0/fs/mod.ts";
import * as path from "https://deno.land/std@0.114.0/path/mod.ts";

import * as utils from "../utils.ts";

import { ActionParams, ID, Tag } from "./common.ts";
import { parseConfigTag, resolveURIString } from "./utils.ts";

import { Config, IConfig } from "./config.ts";

export type FileLock = {
  // typically the url that the uri resolved to, however it may resolve to other uris as well
  resolved_uri: string;

  // the fetched hash
  hash: string;

  // tags generated by combining both the user tags and the fetched tags
  tags: Tag[];
};

export interface ILockfile {
  file_locks: Record<ID, FileLock>;
}

export type LockfileParams = ActionParams & { prev: ILockfile; at: string };

export class Lockfile implements ILockfile {
  #config: IConfig;
  file_locks: ILockfile["file_locks"] = {};

  static from(config: IConfig, params: LockfileParams) {
    return new this(config).generate(params);
  }

  static default() {
    return new this(Config.default());
  }

  constructor(config: IConfig, lock?: ILockfile) {
    this.#config = config;

    if (lock) {
      this.file_locks = lock.file_locks;
    }
  }

  async generate({ dry, prev, at }: LockfileParams) {
    const config = this.#config;
    // const refetchURIs: URL[] = [];
    const filesToMove: Promise<{ path: string; hash: string }>[] = [];

    const lockfile: ILockfile = {
      file_locks: {},
    };

    let tmp: string;
    if (!dry) {
      tmp = await Deno.makeTempDir({ prefix: "imagefile_download_cache" });
    }

    for (const id in config.files) {
      // TODO: actual diffing behavior, using refetchURIs to fetch what's needed
      if (id in prev.file_locks) {
        lockfile.file_locks[id] = prev.file_locks[id];
        continue;
      }

      const fileLock = config.files[id];
      const resolved_uri = resolveURIString(fileLock.source);

      const res = await fetch(resolved_uri);

      if (!res.ok) {
        throw new Error(`[${res.status}] ${res.statusText}`);
      }

      const buf = await res.arrayBuffer();
      const hash = await crypto.subtle.digest("BLAKE3", buf)
        .then(utils.hex16);

      if (!dry) {
        const tmpPath = path.join(tmp!, hash);
        // we save the files to reduce memory usage for now
        // in the future this should be benchmarked
        filesToMove.push(
          Deno.writeFile(tmpPath, new Uint8Array(buf))
            .then(() => ({ path: tmpPath, hash: hash })),
        );
      }

      const tags = fileLock.tags?.flatMap(parseConfigTag) ?? [];

      lockfile.file_locks[id] = { resolved_uri, hash, tags };
    }

    if (!dry) {
      const hashDir = path.resolve(at, ".hash");
      await ensureDir(hashDir);
      // todo: async iter
      const renames = await Promise.all(filesToMove).then((paths) =>
        paths.map((info) => {
          const newPath = path.join(hashDir, info.hash);
          console.debug(`moving ${info.path} to ${newPath}`);
          // TODO: remove hardcode here
          return Deno.rename(info.path, newPath);
        })
      );
      await Promise.all(renames);
    }

    return new Lockfile(config, lockfile);
  }
}
